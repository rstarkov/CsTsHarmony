using System.Text;

namespace CsTsHarmony;

public class ApiCodeGenerator
{
    public ApiDesc Api { get; }
    private List<TypeDesc> _types;
    public List<string> StartLines = new() { "/* AUTOGENERATED FILE - any manual changes will be lost */", "/* eslint-disable */" };
    public HashSet<string> Imports = new();

    public string ServicesClassName = "Services";
    public Func<string, string> ServiceClassName = n => n + "Service";
    public string ServiceClassExtends = "ApiServiceBase";
    public string ServiceOptionsType = "ApiServiceOptions";
    public string ReturnTypeTemplate = "Promise<{0}>";
    public string Fetcher = "fetchJson";
    public Dictionary<Type, string> CustomFetchers = new() { [typeof(void)] = "fetchVoid", [typeof(string)] = "fetchString" };

    // If the key is present but the value is null, this means this type requires no conversion. The "Needed" properties on a converter keep track of whether anything uses it.
    private Dictionary<string, TypeConverter> _typeConverters = new();

    public ApiCodeGenerator(ApiDesc api, IEnumerable<TypeDesc> types)
    {
        Api = api;
        _types = types.ToList();
    }

    public void Output(string filename)
    {
        using var writer = new TypeScriptWriter(filename);
        Output(writer);
    }

    public void Output(TypeScriptWriter writer)
    {
        foreach (var line in StartLines)
            writer.WriteLine(line);
        if (StartLines.Count > 0)
            writer.WriteLine();

        var imports = Imports.ToHashSet();
        foreach (var t in _types.OfType<BasicTypeDesc>())
            if (t.TsConverter != null)
                foreach (var imp in t.TsConverter.GetImports())
                    imports.Add(imp);
        if (imports.Count > 0)
        {
            foreach (var import in imports.Order())
                writer.WriteLine(import);
            writer.WriteLine();
        }

        writer.WriteLine("declare global {");
        writer.WriteLine();
        using (writer.Indent())
        {
            var namespaces = _types.Where(t => t.TsName != null).Select(t => t.TsNamespace).Distinct().Order();
            foreach (var ns in namespaces)
            {
                if (ns != "")
                {
                    writer.WriteLine($"namespace {ns} {{");
                    writer.WriteLine();
                }
                using (writer.Indent(ns != ""))
                {
                    foreach (var t in _types.Where(t => t.TsName != null && t.TsNamespace == ns).OrderBy(t => t.TsName))
                    {
                        OutputTypeDeclaration(writer, t);
                        writer.WriteLine();
                    }
                }
                if (ns != "")
                {
                    writer.WriteLine("}");
                    writer.WriteLine();
                }
            }
        }
        writer.WriteLine("}");
        writer.WriteLine();

        writer.WriteLine($"export class {ServicesClassName} {{");
        using (writer.Indent())
        {
            foreach (var svc in Api.Services.OrderBy(s => s.TsName))
                writer.WriteLine($"public readonly {svc.TsName}: {ServiceClassName(svc.TsName)};");
            writer.WriteLine();
            writer.WriteLine($"public constructor(options?: {ServiceOptionsType}) {{");
            using (writer.Indent())
            {
                foreach (var svc in Api.Services.OrderBy(s => s.TsName))
                    writer.WriteLine($"this.{svc.TsName} = new {ServiceClassName(svc.TsName)}(options);");
            }
            writer.WriteLine("}");
        }
        writer.WriteLine("}");
        writer.WriteLine();
        foreach (var svc in Api.Services.OrderBy(s => s.TsName))
        {
            OutputService(writer, svc);
            writer.WriteLine();
        }
    }

    protected virtual void OutputTypeDeclaration(TypeScriptWriter writer, TypeDesc type)
    {
        // these could be methods on TypeDesc but having them here makes it easier to customise how the code is emitted
        if (type is BasicTypeDesc)
        {
            /* nothing */
        }
        else if (type is EnumTypeDesc et)
            OutputEnumTypeDeclaration(writer, et);
        else if (type is CompositeTypeDesc ct)
            OutputCompositeTypeDeclaration(writer, ct);
        else
            throw new InvalidOperationException();
    }

    protected virtual void OutputEnumTypeDeclaration(TypeScriptWriter writer, EnumTypeDesc e)
    {
        writer.WriteLine($"type {e.TsName} = {e.Values.Select(v => v.Name).Order().JoinString(" | ", "\"", "\"")};");
    }

    protected virtual void OutputCompositeTypeDeclaration(TypeScriptWriter writer, CompositeTypeDesc ct)
    {
        writer.Write($"interface {ct.TsName}");
        if (ct.Extends.Any())
        {
            writer.Write(" extends ");
            writer.Write(ct.Extends.Select(t => GetTypeScript(t, ct.TsNamespace)).Order().JoinString(", "));
        }
        writer.WriteLine(" {");
        using (writer.Indent())
        {
            foreach (var prop in ct.Properties.OrderBy(p => p.Name))
                writer.WriteLine($"{prop.Name}: {GetTypeScript(prop.Type, ct.TsNamespace)};");
        }
        writer.WriteLine("}");
    }

    protected void OutputService(TypeScriptWriter writer, ServiceDesc s)
    {
        var convertersUsedFrom = new HashSet<TypeConverter>();
        var convertersUsedTo = new HashSet<TypeConverter>();

        writer.WriteLine($"export class {ServiceClassName(s.TsName)}{(ServiceClassExtends == null ? "" : $" extends {ServiceClassExtends}")} {{");
        writer.WriteLine();
        using (writer.Indent())
        {
            writer.WriteLine("public endpoints = {");
            using (writer.Indent())
            {
                foreach (var method in s.Methods.OrderBy(m => m.TsName))
                    foreach (var httpMethod in method.HttpMethods.Order())
                    {
                        var url = ApiGeneratorHelper.MethodUrlTemplateString(method, val => "${encodeURIComponent('' + " + val + ")}");
                        writer.WriteLine($"{getMethodName(method, httpMethod)}: ({getMethodParams(method.Parameters.Where(p => p.Location is ParameterLocation.UrlSegment or ParameterLocation.QueryString))}): string => `{url}`,");
                    }
            }
            writer.WriteLine("};");
            writer.WriteLine();
            writer.WriteLine($"public constructor(options?: {ServiceOptionsType}) {{");
            using (writer.Indent())
            {
                writer.WriteLine("super(options);");
                writer.WriteLine();

                foreach (var method in s.Methods.OrderBy(m => m.TsName))
                    foreach (var httpMethod in method.HttpMethods.Order())
                        writer.WriteLine($"this.{getMethodName(method, httpMethod)} = this.{getMethodName(method, httpMethod)}.bind(this);");
            }
            writer.WriteLine("}");
            writer.WriteLine();
            foreach (var method in s.Methods.OrderBy(m => m.TsName))
            {
                foreach (var httpMethod in method.HttpMethods.Order())
                {
                    bool canDirectReturn = getConverter(method.ReturnType) == null;
                    writer.Write($"public {(canDirectReturn ? "" : "async ")}{getMethodName(method, httpMethod)}(");
                    writer.Write(getMethodParams(method.Parameters));
                    writer.WriteLine($"): {string.Format(ReturnTypeTemplate, GetTypeScript(method.ReturnType, ""))} {{");
                    using (writer.Indent())
                    {
                        writer.WriteLine($"let url = this.endpoints.{getMethodName(method, httpMethod)}({method.Parameters.Where(p => p.Location is ParameterLocation.UrlSegment or ParameterLocation.QueryString).Select(p => p.TsName).JoinString(", ")});");

                        // Output parameter type conversions
                        foreach (var p in method.Parameters)
                            OutputTypeConversion(writer, p.TsName, p.Type, toTypeScript: false);

                        // Build request body
                        var bodyParams = method.Parameters.Where(p => p.Location == ParameterLocation.RequestBody).OrderBy(p => p.TsName).ToList();
                        if (bodyParams.Count > 1 && (method.BodyEncoding == BodyEncoding.Raw || method.BodyEncoding == BodyEncoding.Json))
                            throw new InvalidOperationException($"The body encoding for this method allows for at most one body parameter. Offending parameters: [{bodyParams.Select(p => p.TsName).JoinString(", ")}], method {method.Method.Name}, controller {s.ControllerType.FullName}");
                        var fetchOpts = $"method: '{httpMethod.ToUpper()}'";
                        if (bodyParams.Count > 0)
                        {
                            if (method.BodyEncoding == BodyEncoding.Raw)
                            {
                                fetchOpts += $", body: {bodyParams[0].TsName}";
                            }
                            else if (method.BodyEncoding == BodyEncoding.Json)
                            {
                                fetchOpts += $", body: JSON.stringify({bodyParams[0].TsName}), headers: {{ 'Content-Type': 'application/json' }}";
                            }
                            else if (method.BodyEncoding == BodyEncoding.FormUrlEncoded)
                            {
                                writer.WriteLine("let __body = new URLSearchParams();");
                                foreach (var bp in bodyParams)
                                    writer.WriteLine($"__body.append('{bp.TsName}', '' + {bp.TsName});");
                                fetchOpts += ", body: __body";
                            }
                            else if (method.BodyEncoding == BodyEncoding.MultipartFormData)
                            {
                                writer.WriteLine("let __body = new FormData();");
                                foreach (var bp in bodyParams)
                                    writer.WriteLine($"__body.append('{bp.TsName}', '' + {bp.TsName});");
                                fetchOpts += ", body: __body";
                                throw new NotImplementedException("FormData encoding is not fully implemented."); // no support for file name, parameter is always stringified with no support for Blob
                            }
                            else
                                throw new Exception($"Unexpected {nameof(method.BodyEncoding)}: {method.BodyEncoding}");
                        }

                        // Output call
                        var getter = Fetcher;
                        if (!method.ReturnType.Array && CustomFetchers.ContainsKey(method.ReturnType.RawType))
                            getter = CustomFetchers[method.ReturnType.RawType];
                        if (canDirectReturn)
                            writer.WriteLine($"return this.{getter}(url, {{ {fetchOpts} }}) as Promise<{GetTypeScript(method.ReturnType, "")}>;");
                        else
                            writer.WriteLine($"let result = await this.{getter}(url, {{ {fetchOpts} }}) as {GetTypeScript(method.ReturnType, "")};");

                        if (!canDirectReturn)
                        {
                            // Output return type conversion
                            OutputTypeConversion(writer, "result", method.ReturnType, toTypeScript: true);
                            writer.WriteLine("return result;");
                        }
                    }
                    writer.WriteLine("}");
                    writer.WriteLine();
                }
            }

            // Output type converters
            foreach (var tc in _typeConverters.Values.Where(c => c != null).OrderBy(c => GetConverterName(c.ForType)))
            {
                if (convertersUsedFrom.Contains(tc))
                {
                    writer.WriteLine($"private {GetConverterName(tc.ForType, toTypeScript: false)}(val: {GetTypeScript(tc.ForType, "")}): any {{");
                    using (writer.Indent())
                        tc.WriteFunctionBody(writer, false);
                    writer.WriteLine("}");
                    writer.WriteLine();
                }
                if (convertersUsedTo.Contains(tc))
                {
                    writer.WriteLine($"private {GetConverterName(tc.ForType, toTypeScript: true)}(val: any): {GetTypeScript(tc.ForType, "")} {{");
                    using (writer.Indent())
                        tc.WriteFunctionBody(writer, true);
                    writer.WriteLine("}");
                    writer.WriteLine();
                }
            }
        }
        writer.WriteLine("}");

        void OutputTypeConversion(TypeScriptWriter writer, string lvalue, TypeRef type, bool toTypeScript)
        {
            var converter = getConverter(type);
            if (converter == null)
                return;
            MarkUsedConverters(converter, toTypeScript);
            writer.WriteLine($"if ({lvalue})");
            using (writer.Indent())
                writer.WriteLine($"{lvalue} = this.{GetConverterName(converter.ForType, toTypeScript)}({lvalue});");
        }

        void MarkUsedConverters(TypeConverter converter, bool toTypeScript)
        {
            var set = !toTypeScript ? convertersUsedFrom : convertersUsedTo;
            if (!set.Add(converter))
                return;
            foreach (var used in converter.UsesConverters)
                MarkUsedConverters(used, toTypeScript);
        }
    }

    private string getMethodName(MethodDesc method, string httpMethod)
    {
        return method.TsName + (method.HttpMethods.Count == 1 ? "" : httpMethod.Substring(0, 1) + httpMethod.Substring(1).ToLower());
    }

    private string getMethodParams(IEnumerable<MethodParameterDesc> parameters)
    {
        var sb = new StringBuilder();
        bool first = true;
        foreach (var p in parameters)
        {
            if (!first)
                sb.Append(", ");
            sb.Append($"{p.TsName}{(p.Optional ? "?" : "")}: {GetTypeScript(p.Type, "")}");
            first = false;
        }
        return sb.ToString();
    }

    private class TypeConverter
    {
        public TypeRef ForType;
        // conversion function is called only if the value to be converted is truthy
        public Action<TypeScriptWriter, bool> WriteFunctionBody;
        public HashSet<TypeConverter> UsesConverters = new HashSet<TypeConverter>();
    }

    private TypeConverter getConverter(TypeRef typeref)
    {
        // converters are emitted as not nullable on all types because callers avoid invoking converters for non-truthy values
        if (typeref.Nullable || (typeref.Array && typeref.ArrayNullable))
            return getConverter(new TypeRef { MappedType = typeref.MappedType, RawType = typeref.RawType, Array = typeref.Array });

        var key = GetConverterName(typeref);
        if (_typeConverters.TryGetValue(key, out var converter))
            return converter;

        converter = new TypeConverter { ForType = typeref };
        // there must be no early returns below; we must populate this converter and add it to the dictionary

        if (typeref.Array)
        {
            var elConverter = getConverter(new TypeRef { MappedType = typeref.MappedType, RawType = typeref.MappedType.RawType });
            if (elConverter == null)
                converter = null;
            else
            {
                converter.UsesConverters.Add(elConverter);
                converter.WriteFunctionBody = (writer, toTypeScript) =>
                {
                    writer.WriteLine("for (let i = 0; i < val.length; i++)");
                    using (writer.Indent())
                    {
                        writer.WriteLine("if (val[i])");
                        using (writer.Indent())
                            writer.WriteLine($"val[i] = this.{GetConverterName(elConverter.ForType, toTypeScript)}(val[i]);");
                    }
                    writer.WriteLine("return val;");
                };
            }
        }
        // not array therefore it's just a reference to a TypeDesc
        else if (typeref.MappedType is BasicTypeDesc bt)
        {
            if (bt.TsConverter == null)
                converter = null;
            else
            {
                converter.WriteFunctionBody = (writer, toTypeScript) =>
                {
                    if (!toTypeScript)
                        writer.WriteLine($"return {bt.TsConverter.ConvertFromTypeScript("val")};");
                    else
                        writer.WriteLine($"return {bt.TsConverter.ConvertToTypeScript("val")};");
                };
            }
        }
        else if (typeref.MappedType is EnumTypeDesc et)
        {
            // TODO: Flags
            converter = null;
        }
        else if (typeref.MappedType is CompositeTypeDesc ct)
        {
            var propConverters = ct.Properties.Select(p => new { prop = p, conv = getConverter(p.Type) }).Where(x => x.conv != null).ToList();
            if (propConverters.Count == 0)
                converter = null;
            else
            {
                foreach (var pc in propConverters)
                    converter.UsesConverters.Add(pc.conv);
                converter.WriteFunctionBody = (writer, toTypeScript) =>
                {
                    foreach (var pc in propConverters)
                    {
                        writer.WriteLine($"if (val.{pc.prop.Name})");
                        using (writer.Indent())
                            writer.WriteLine($"val.{pc.prop.Name} = this.{GetConverterName(pc.conv.ForType, toTypeScript)}(val.{pc.prop.Name});");
                    }
                    writer.WriteLine("return val;");
                };
            }
        }
        else
            throw new Exception();

        _typeConverters[key] = converter;
        return converter;
    }

    private static string GetTypeScript(TypeRef tr, string fromNamespace)
    {
        var result = tr.MappedType.TsReference(fromNamespace);
        bool needParens = false;
        if (tr.Nullable)
        {
            result = result + " | null";
            needParens = true;
        }
        if (tr.Array)
        {
            if (needParens)
                result = "(" + result + ")";
            result = result + "[]";
            needParens = false;
            if (tr.ArrayNullable)
            {
                result = result + " | null";
                needParens = true;
            }
        }
        return result;
    }

    private static string GetConverterName(TypeRef tr, bool? toTypeScript = null)
    {
        // multiple C# types can map to the same TS type and we want different converters for those, so we go by the C# type name here
        var name = tr.RawType.FullName.Replace(".", "") + (tr.Array ? "Array" : ""); // nullability is irrelevant / uniform for converters as null values are not passed through converters
        //name = MD5.HashData(Encoding.UTF8.GetBytes(name)).Take(8).Select(b => $"{b:x2}").JoinString();
        return toTypeScript == null ? name : ("convert" + (toTypeScript == true ? "ToTs_" : "FromTs_") + name);
    }
}

/// <summary>
/// Does not generate model types. This is only useful for integration tests in a test project that also references the server project to get the model types directly.
/// </summary>
public class CsTestClientGenerator
{
    private ApiDesc _api;

    public string ClassAccessibility = "internal";
    public string Namespace = null;
    public string ServicesClass = "ApiServices";

    public CsTestClientGenerator(ApiDesc api)
    {
        _api = api;
    }

    public void Output(string filename)
    {
        using var writer = new CodeWriter(filename);
        Output(writer);
    }

    private void Output(CodeWriter writer)
    {
        writer.WriteLine("// AUTOGENERATED FILE");
        writer.WriteLine("using System.Threading.Tasks;");
        writer.WriteLine();
        if (Namespace != null)
        {
            writer.WriteLine($"namespace {Namespace};");
            writer.WriteLine();
        }

        writer.WriteLine($"{ClassAccessibility} class {ServicesClass}");
        writer.WriteLine("{");
        using (writer.Indent())
        {
            foreach (var svc in _api.Services)
                writer.WriteLine($"public {svc.TsName}Service {svc.TsName};");
            writer.WriteLine();
            writer.WriteLine($"public {ServicesClass}(ApiServiceOptions options)");
            writer.WriteLine("{");
            using (writer.Indent())
                foreach (var svc in _api.Services)
                    writer.WriteLine($"{svc.TsName} = new(options);");
            writer.WriteLine("}");
        }
        writer.WriteLine("}");
        writer.WriteLine();

        foreach (var svc in _api.Services)
        {
            writer.WriteLine($"{ClassAccessibility} class {svc.TsName}Service : ApiServiceBase");
            writer.WriteLine("{");
            using (writer.Indent())
            {
                writer.WriteLine($"public static class Endpoints");
                writer.WriteLine("{");
                using (writer.Indent())
                {
                    foreach (var method in svc.Methods.OrderBy(m => m.TsName))
                        foreach (var httpMethod in method.HttpMethods.Order())
                            writer.WriteLine($"public static string {getMethodName(method, httpMethod)}({getMethodParams(method.Parameters.Where(p => p.Location is ParameterLocation.UrlSegment or ParameterLocation.QueryString))}) => $\"{ApiGeneratorHelper.MethodUrlTemplateString(method, val => "{UrlEncode(" + val + ")}")}\";");
                }
                writer.WriteLine("}");
                writer.WriteLine();
                writer.WriteLine($"public {svc.TsName}Service(ApiServiceOptions options) : base(options)");
                writer.WriteLine("{");
                writer.WriteLine("}");
                writer.WriteLine();
                foreach (var method in svc.Methods.OrderBy(m => m.TsName))
                    foreach (var httpMethod in method.HttpMethods.Order())
                    {
                        writer.Write($"public {getCsTaskType(method.ReturnType)} {getMethodName(method, httpMethod)}(");
                        writer.Write(getMethodParams(method.Parameters));
                        writer.WriteLine(")");
                        writer.WriteLine("{");
                        using (writer.Indent())
                        {
                            writer.WriteLine($"var url = Endpoints.{getMethodName(method, httpMethod)}({method.Parameters.Where(p => p.Location is ParameterLocation.UrlSegment or ParameterLocation.QueryString).Select(p => p.TsName).JoinString(", ")});");
                            //writer.WriteLine($"var url = $\"{Helper.MethodUrlTemplateString(method, val => "{UrlEncode(" + val + ")}")}\";");

                            var bodyParams = method.Parameters.Where(p => p.Location == ParameterLocation.RequestBody).OrderBy(p => p.TsName).ToList();
                            if (bodyParams.Count > 1 && (method.BodyEncoding == BodyEncoding.Raw || method.BodyEncoding == BodyEncoding.Json))
                                throw new InvalidOperationException($"The body encoding for this method allows for at most one body parameter. Offending parameters: [{bodyParams.Select(p => p.TsName).JoinString(", ")}], method {method.Method.Name}, controller {svc.ControllerType.FullName}");
                            var content = "null";
                            if (bodyParams.Count > 0)
                            {
                                if (method.BodyEncoding == BodyEncoding.Raw)
                                    content = $"RawContent({bodyParams[0].TsName})";
                                else if (method.BodyEncoding == BodyEncoding.Json)
                                    content = $"JsonContent({bodyParams[0].TsName})";
                                else if (method.BodyEncoding == BodyEncoding.FormUrlEncoded)
                                    throw new NotImplementedException();
                                else if (method.BodyEncoding == BodyEncoding.MultipartFormData)
                                    throw new NotImplementedException("FormData encoding is not fully implemented.");
                                else
                                    throw new Exception($"Unexpected {nameof(method.BodyEncoding)}: {method.BodyEncoding}");
                            }

                            var getter = $"FetchJson<{method.ReturnType}>";
                            if (!method.ReturnType.Array)
                            {
                                if (method.ReturnType.RawType == typeof(string)) getter = "FetchString";
                                else if (method.ReturnType.RawType == typeof(void)) getter = "FetchVoid";
                            }
                            writer.WriteLine($"return {getter}(url, \"{httpMethod}\", {content});");
                        }
                        writer.WriteLine("}");
                    }
            }
            writer.WriteLine("}");
            writer.WriteLine();
        }
    }

    private string getMethodName(MethodDesc method, string httpMethod)
    {
        return method.TsName + (method.HttpMethods.Count == 1 ? "" : httpMethod.Substring(0, 1) + httpMethod.Substring(1).ToLower());
    }

    private string getMethodParams(IEnumerable<MethodParameterDesc> parameters)
    {
        var sb = new StringBuilder();
        bool first = true;
        foreach (var p in parameters)
        {
            if (!first)
                sb.Append(", ");
            sb.Append($"{getCs(p.Type)} {p.TsName}{(p.Optional ? " = default" : "")}");
            first = false;
        }
        return sb.ToString();
    }

    private string getCsTaskType(TypeRef type)
    {
        if (type.RawType == typeof(void)) return "Task";
        return $"Task<{getCs(type)}>";
    }

    private string getCs(TypeRef type)
    {
        if (type.RawType == typeof(void)) return "void";
        if (type.RawType == typeof(string)) return "string";
        if (type.RawType == typeof(int)) return "int";
        return type.ToString();
    }
}

internal static class ApiGeneratorHelper
{
    public static string MethodUrlTemplateString(MethodDesc method, Func<string, string> urlEncodeInString)
    {
        var url = new StringBuilder();
        bool first = true;
        foreach (var segment in method.UrlTemplate.Segments)
        {
            if (first)
                first = false;
            else
                url.Append('/');
            if (!segment.IsSimple)
                throw new NotImplementedException(); // need a test case to implement this
            if (segment.Parts[0].IsLiteral)
                url.Append(segment.Parts[0].Text);
            else if (segment.Parts[0].IsParameter)
                url.Append(urlEncodeInString(segment.Parts[0].Name));
            else
                throw new NotImplementedException(); // need a test case to implement this
        }
        first = true;
        foreach (var p in method.Parameters.Where(p => p.Location == ParameterLocation.QueryString).OrderBy(p => p.TsName))
        {
            url.Append(first ? '?' : '&');
            url.Append(p.TsName + "=" + urlEncodeInString(p.TsName));
            first = false;
        }
        return url.ToString();
    }
}
