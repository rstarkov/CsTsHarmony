using System;
using System.Collections.Generic;
using System.Linq;

namespace CsTsApi
{
    public class ApiCodeGenerator
    {
        public string ReturnTypeTemplate = "Promise<{0}>";

        private string getName(string fullname) => fullname.Contains(".") ? fullname.Substring(fullname.LastIndexOf('.') + 1) : fullname;
        private string getNamespace(string fullname) => fullname.Contains(".") ? fullname.Substring(0, fullname.LastIndexOf('.')) : null;

        public void Output(TypeScriptWriter writer, ApiDesc api)
        {
            writer.WriteLine("// AUTOGENERATED FILE - any manual changes will be lost");
            writer.WriteLine();
            if (api.Imports.Count > 0)
            {
                foreach (var import in api.Imports.Order())
                    writer.WriteLine(import);
                writer.WriteLine();
            }
            writer.WriteLine("declare global {");
            writer.WriteLine();
            using (writer.Indent())
            {
                var namespaces = api.Interfaces.Values.Select(i => getNamespace(i.TsName)).Concat(api.Enums.Values.Select(e => getNamespace(e.TsName))).Distinct().Order();
                foreach (var ns in new string[] { null }.Concat(namespaces))
                {
                    var enums = api.Enums.Values.Where(e => getNamespace(e.TsName) == ns).OrderBy(e => e.TsName).ToList();
                    var interfaces = api.Interfaces.Values.Where(i => getNamespace(i.TsName) == ns).OrderBy(e => e.TsName).ToList();
                    if (enums.Count == 0 && interfaces.Count == 0)
                        continue;
                    if (ns != null)
                    {
                        writer.WriteLine($"namespace {ns} {{");
                        writer.WriteLine();
                    }
                    using (writer.Indent(ns != null))
                    {
                        foreach (var e in enums)
                        {
                            OutputEnum(writer, e);
                            writer.WriteLine();
                        }
                        foreach (var i in interfaces)
                        {
                            OutputInterface(writer, i);
                            writer.WriteLine();
                        }
                    }
                    if (ns != null)
                    {
                        writer.WriteLine("}");
                        writer.WriteLine();
                    }
                }
            }
            writer.WriteLine("}");
            writer.WriteLine();

            writer.WriteLine("export class Services {");
            using (writer.Indent())
            {
                foreach (var svc in api.Services.OrderBy(s => s.Name))
                    writer.WriteLine($"public readonly {svc.Name}: {svc.Name}Service;");
                writer.WriteLine();
                writer.WriteLine("public constructor(hostname: string) {");
                using (writer.Indent())
                {
                    foreach (var svc in api.Services.OrderBy(s => s.Name))
                        writer.WriteLine($"this.{svc.Name} = new {svc.Name}Service(hostname);");
                }
                writer.WriteLine("}");
            }
            writer.WriteLine("}");
            writer.WriteLine();
            foreach (var svc in api.Services.OrderBy(s => s.Name))
            {
                OutputService(writer, svc);
                writer.WriteLine();
            }
        }

        protected void OutputEnum(TypeScriptWriter writer, ApiEnumDesc e)
        {
            writer.WriteLine($"type {getName(e.TsName)} = {e.Values.Select(v => v.TsName).Order().JoinString(" | ", "\"", "\"")};");
        }

        protected void OutputInterface(TypeScriptWriter writer, ApiInterfaceDesc i)
        {
            writer.Write($"interface {getName(i.TsName)}");
            if (i.Extends.Any())
            {
                writer.Write(" extends ");
                writer.Write(i.Extends.Select(e => getNamespace(e.TsName) == getNamespace(i.TsName) ? getName(e.TsName) : e.TsName).Order().JoinString(", "));
            }
            writer.WriteLine(" {");
            using (writer.Indent())
            {
                foreach (var prop in i.Properties.OrderBy(p => p.TsName))
                    writer.WriteLine($"{prop.TsName}: {prop.TsType.GetTypeScript()};");
            }
            writer.WriteLine("}");
        }

        protected void OutputService(TypeScriptWriter writer, ApiServiceDesc s)
        {
            _convertersUsedFrom = new HashSet<TypeConverter>();
            _convertersUsedTo = new HashSet<TypeConverter>();
            writer.WriteLine($"export class {s.Name}Service extends ApiServiceBase {{");
            writer.WriteLine();
            using (writer.Indent())
            {
                writer.WriteLine("private _hostname: string;");
                writer.WriteLine();
                writer.WriteLine("public constructor(hostname: string) {");
                using (writer.Indent())
                {
                    writer.WriteLine("super();");
                    writer.WriteLine("this._hostname = (hostname.substr(-1) == '/') ? hostname : hostname + '/';");
                }
                writer.WriteLine("}");
                writer.WriteLine();
                foreach (var method in s.Methods.OrderBy(m => m.TsName))
                {
                    foreach (var httpMethod in method.HttpMethods.Order())
                    {
                        bool canDirectReturn = getConverter(method.TsReturnType) == null;
                        writer.Write($"public {(canDirectReturn ? "" : "async ")}{getMethodName(method, httpMethod)}(");
                        bool first = true;
                        foreach (var p in method.Parameters)
                        {
                            if (!first)
                                writer.Write(", ");
                            writer.Write($"{p.TsName}: {p.TsType.GetTypeScript()}");
                            first = false;
                        }
                        writer.WriteLine($"): {string.Format(ReturnTypeTemplate, method.TsReturnType.GetTypeScript())} {{");
                        using (writer.Indent())
                        {
                            var url = method.UrlPath;
                            bool first2 = true;
                            foreach (var p in method.Parameters.Where(p => p.Location == ParameterLocation.QueryString).OrderBy(p => p.TsName))
                            {
                                url += (first2 ? '?' : '&') + p.TsName + "=${encodeURIComponent('' + " + p.TsName + ")}";
                                first2 = false;
                            }
                            writer.WriteLine($"let url = this._hostname + `{url}`;");

                            // Output parameter type conversions
                            foreach (var p in method.Parameters)
                                OutputTypeConversion(writer, p.TsName, p.TsType, toTypeScript: false);

                            // Build request body
                            var bodyParams = method.Parameters.Where(p => p.Location == ParameterLocation.RequestBody).OrderBy(p => p.TsName).ToList();
                            if (bodyParams.Count > 0 && httpMethod == "GET")
                                throw new InvalidOperationException($"GET requests must not have any body parameters. Offending parameter: {bodyParams[0].TsName}, method {method.Method.Name}, controller {s.Controller.FullName}");
                            if (bodyParams.Count > 1 && (method.BodyEncoding == BodyEncoding.Raw || method.BodyEncoding == BodyEncoding.Json))
                                throw new InvalidOperationException($"The body encoding for this method allows for at most one body parameter. Offending parameters: [{bodyParams.Select(p => p.TsName).JoinString(", ")}], method {method.Method.Name}, controller {s.Controller.FullName}");
                            var bodyCode = "";
                            if (bodyParams.Count > 0)
                            {
                                if (method.BodyEncoding == BodyEncoding.Raw)
                                {
                                    bodyCode = $", body: {bodyParams[0].TsName}";
                                }
                                else if (method.BodyEncoding == BodyEncoding.Json)
                                {
                                    bodyCode = $", body: JSON.stringify({bodyParams[0].TsName}), headers: {{ 'Content-Type': 'application/json' }}";
                                }
                                else if (method.BodyEncoding == BodyEncoding.FormUrlEncoded)
                                {
                                    writer.WriteLine("let __body = new URLSearchParams();");
                                    foreach (var bp in bodyParams)
                                        writer.WriteLine($"__body.append('{bp.TsName}', '' + {bp.TsName});");
                                    bodyCode = ", body: __body";
                                }
                                else if (method.BodyEncoding == BodyEncoding.MultipartFormData)
                                {
                                    writer.WriteLine("let __body = new FormData();");
                                    foreach (var bp in bodyParams)
                                        writer.WriteLine($"__body.append('{bp.TsName}', '' + {bp.TsName});");
                                    bodyCode = ", body: __body";
                                    throw new NotImplementedException("FormData encoding is not fully implemented."); // no support for file name, parameter is always stringified with no support for Blob
                                }
                                else
                                    throw new Exception($"Unexpected {nameof(method.BodyEncoding)}: {method.BodyEncoding}");
                            }

                            // Output call
                            var sendCookies = s.SendCookies == SendCookies.Always ? "include" : s.SendCookies == SendCookies.SameOriginOnly ? "same-origin" : s.SendCookies == SendCookies.Never ? "omit" : throw new Exception();
                            if (canDirectReturn)
                                writer.Write("return ");
                            else
                                writer.Write("let result = await ");
                            writer.WriteLine($"this.{httpMethod}<{method.TsReturnType.GetTypeScript()}>(url, {{ credentials: '{sendCookies}'{bodyCode} }});");

                            if (!canDirectReturn)
                            {
                                // Output return type conversion
                                OutputTypeConversion(writer, "result", method.TsReturnType, toTypeScript: true);

                                writer.WriteLine("return result;");
                            }
                        }
                        writer.WriteLine("}");
                        writer.WriteLine();
                    }
                }

                // Output type converters
                foreach (var tc in _typeConverters.Values.Where(c => c != null).OrderBy(c => c.ForType.GetHash()))
                {
                    if (_convertersUsedFrom.Contains(tc))
                    {
                        writer.WriteLine($"private {tc.FunctionName(toTypeScript: false)}(val: {tc.ForType.GetTypeScript()}): any {{");
                        using (writer.Indent())
                            tc.WriteFunctionBody(writer, false);
                        writer.WriteLine("}");
                        writer.WriteLine();
                    }
                    if (_convertersUsedTo.Contains(tc))
                    {
                        writer.WriteLine($"private {tc.FunctionName(toTypeScript: true)}(val: any): {tc.ForType.GetTypeScript()} {{");
                        using (writer.Indent())
                            tc.WriteFunctionBody(writer, true);
                        writer.WriteLine("}");
                        writer.WriteLine();
                    }
                }
            }
            writer.WriteLine("}");
        }

        private string getMethodName(ApiMethodDesc method, string httpMethod)
        {
            return method.TsName + (method.HttpMethods.Count == 1 ? "" : httpMethod.Substring(0, 1) + httpMethod.Substring(1).ToLower());
        }

        private class TypeConverter
        {
            public ApiTypeDesc ForType;
            // conversion function is called only if the value to be converted is truthy
            public Action<TypeScriptWriter, bool> WriteFunctionBody;
            public string FunctionName(bool toTypeScript) => "convert" + (toTypeScript ? "ToTs_" : "FromTs_") + ForType.GetHash();
            public HashSet<TypeConverter> UsesConverters = new HashSet<TypeConverter>();
        }

        // If the key is present but the value is null, this means this type requires no conversion. The "Needed" properties on a converter keep track of whether anything uses it.
        private Dictionary<string, TypeConverter> _typeConverters = new Dictionary<string, TypeConverter>();
        private HashSet<TypeConverter> _convertersUsedFrom, _convertersUsedTo;

        private void OutputTypeConversion(TypeScriptWriter writer, string lvalue, ApiTypeDesc type, bool toTypeScript)
        {
            var converter = getConverter(type);
            if (converter == null)
                return;
            MarkUsedConverters(converter, toTypeScript);
            writer.WriteLine($"if ({lvalue})");
            using (writer.Indent())
                writer.WriteLine($"{lvalue} = this.{converter.FunctionName(toTypeScript)}({lvalue});");
        }

        private void MarkUsedConverters(TypeConverter converter, bool toTypeScript)
        {
            var set = !toTypeScript ? _convertersUsedFrom : _convertersUsedTo;
            if (!set.Add(converter))
                return;
            foreach (var used in converter.UsesConverters)
                MarkUsedConverters(used, toTypeScript);
        }

        private TypeConverter getConverter(ApiTypeDesc type)
        {
            var key = type.GetTypeScript();
            if (!_typeConverters.TryGetValue(key, out var converter))
            {
                converter = new TypeConverter { ForType = type };

                if (type.BasicType != null)
                {
                    if (type.TypeMapper == null)
                        converter = null;
                    else
                    {
                        converter.WriteFunctionBody = (writer, toTypeScript) =>
                        {
                            if (!toTypeScript)
                                writer.WriteLine($"return {type.TypeMapper.ConvertFromTypeScript("val")};");
                            else
                                writer.WriteLine($"return {type.TypeMapper.ConvertToTypeScript("val")};");
                        };
                    }
                }
                else if (type.EnumType != null)
                {
                    // TODO: Flags
                    converter = null;
                }
                else if (type.ArrayElementType != null)
                {
                    var elConverter = getConverter(type.ArrayElementType);
                    if (elConverter == null)
                        converter = null;
                    else
                    {
                        converter.UsesConverters.Add(elConverter);
                        converter.WriteFunctionBody = (writer, toTypeScript) =>
                        {
                            writer.WriteLine("for (let i = 0; i < val.length; i++)");
                            using (writer.Indent())
                            {
                                writer.WriteLine("if (val[i])");
                                using (writer.Indent())
                                    writer.WriteLine($"val[i] = this.{elConverter.FunctionName(toTypeScript)}(val[i]);");
                            }
                            writer.WriteLine("return val;");
                        };
                    }
                }
                else if (type.InterfaceType != null)
                {
                    var propConverters = type.InterfaceType.Properties.Select(p => new { prop = p, conv = getConverter(p.TsType) }).Where(x => x.conv != null).ToList();
                    if (propConverters.Count == 0)
                        converter = null;
                    else
                    {
                        foreach (var pc in propConverters)
                            converter.UsesConverters.Add(pc.conv);
                        converter.WriteFunctionBody = (writer, toTypeScript) =>
                        {
                            foreach (var pc in propConverters)
                            {
                                writer.WriteLine($"if (val.{pc.prop.TsName})");
                                using (writer.Indent())
                                    writer.WriteLine($"val.{pc.prop.TsName} = this.{pc.conv.FunctionName(toTypeScript)}(val.{pc.prop.TsName});");
                            }
                            writer.WriteLine("return val;");
                        };
                    }
                }
                else
                    throw new Exception();
            }

            _typeConverters[key] = converter;
            return converter;
        }
    }
}
