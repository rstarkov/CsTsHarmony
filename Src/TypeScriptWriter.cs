namespace CsTsHarmony;

public class CodeWriter : IDisposable
{
    protected TextWriter _writer;
    private bool _needIndent = true;
    private int _indentLevel = 0;

    public string IndentTemplate = "    ";

    public CodeWriter(string filepath)
    {
        filepath = Path.GetFullPath(filepath);
        Directory.CreateDirectory(Path.GetDirectoryName(filepath));
        init(new StreamWriter(File.Open(filepath, FileMode.Create, FileAccess.Write, FileShare.Read)));
    }

    public CodeWriter(TextWriter writer)
    {
        init(writer);
    }

    protected CodeWriter() { }

    protected void init(TextWriter writer)
    {
        _writer = writer;
    }

    public void Dispose()
    {
        _writer?.Dispose();
        _writer = null;
    }

    private class Indenter : IDisposable
    {
        private CodeWriter _owner;
        private bool _indent;

        public Indenter(CodeWriter owner, bool indent)
        {
            _owner = owner;
            _indent = indent;
            if (indent)
                _owner._indentLevel++;
        }

        void IDisposable.Dispose()
        {
            if (_owner != null && _indent)
                _owner._indentLevel--;
            _owner = null;
        }
    }

    public IDisposable Indent(bool indent = true)
    {
        return new Indenter(this, indent);
    }

    public void Write(string str)
    {
        if (_needIndent && str != null && str != "")
            for (int i = 0; i < _indentLevel; i++)
                _writer.Write(IndentTemplate);
        _needIndent = false;
        _writer.Write(str);
    }

    public void WriteLine(string str = null)
    {
        Write(str);
        _writer.WriteLine();
        _needIndent = true;
    }
}

public class TypeScriptWriter : CodeWriter
{
    public List<string> StartLines = new() { "/* AUTOGENERATED FILE - any manual changes will be lost */", "/* eslint-disable */" };
    public HashSet<string> Imports = new();

    private MemoryStream _buffer = new();

    public TypeScriptWriter()
    {
        init(new StreamWriter(_buffer));
    }

    public void Save(string filepath)
    {
        filepath = Path.GetFullPath(filepath);
        Directory.CreateDirectory(Path.GetDirectoryName(filepath));
        using var writer = new StreamWriter(File.Open(filepath, FileMode.Create, FileAccess.Write, FileShare.Read));

        foreach (var line in StartLines)
            writer.WriteLine(line);
        if (StartLines.Count > 0)
            writer.WriteLine();

        var imports = Imports.ToHashSet();
        if (imports.Count > 0)
        {
            foreach (var import in imports.Order())
                writer.WriteLine(import);
            writer.WriteLine();
        }

        writer.Flush();
        _writer.Flush();
        _buffer.Position = 0;
        _buffer.CopyTo(writer.BaseStream);
    }

    public static string TypeSignature(TypeDesc type, string fromNamespace)
    {
        if (type is BasicTypeDesc bt)
            return bt.TgtType;
        else if (type is EnumTypeDesc et)
            return fromNamespace == et.TgtNamespace ? et.TgtName : $"{et.TgtNamespace}.{et.TgtName}";
        else if (type is CompositeTypeDesc ct)
            return fromNamespace == ct.TgtNamespace ? ct.TgtName : $"{ct.TgtNamespace}.{ct.TgtName}";
        else if (type is NullableTypeDesc nt)
            return $"{TypeSignature(nt.ElementType, fromNamespace)} | null";
        else if (type is ArrayTypeDesc at)
            return $"{ParenthesizeType(TypeSignature(at.ElementType, fromNamespace))}[]";
        else
            throw new InvalidOperationException("ilsauwhf");
    }

    public static string ParenthesizeType(string type) => type.Any(c => c == ' ' || c == '|' || c == '[') ? $"({type})" : type;
}
